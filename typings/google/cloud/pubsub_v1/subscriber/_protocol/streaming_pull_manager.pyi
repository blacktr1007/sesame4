"""
This type stub file was generated by pyright.
"""

import typing
import google.cloud.pubsub_v1.subscriber.message
from typing import Any, Callable, Iterable, List, Optional, Tuple
from google.cloud.pubsub_v1 import subscriber, types
from google.cloud.pubsub_v1.subscriber._protocol import dispatcher, histogram, leaser, requests
from google.cloud.pubsub_v1.subscriber.scheduler import ThreadScheduler

if typing.TYPE_CHECKING:
    ...
_LOGGER = ...
_REGULAR_SHUTDOWN_THREAD_NAME = ...
_RPC_ERROR_THREAD_NAME = ...
_RETRYABLE_STREAM_ERRORS = ...
_TERMINATING_STREAM_ERRORS = ...
_MAX_LOAD = ...
_RESUME_THRESHOLD = ...
_MIN_ACK_DEADLINE_SECS_WHEN_EXACTLY_ONCE_ENABLED = ...
_EXACTLY_ONCE_DELIVERY_TEMPORARY_RETRY_ERRORS = ...
class StreamingPullManager:
    """The streaming pull manager coordinates pulling messages from Pub/Sub,
    leasing them, and scheduling them to be processed.

    Args:
        client:
            The subscriber client used to create this instance.
        subscription:
            The name of the subscription. The canonical format for this is
            ``projects/{project}/subscriptions/{subscription}``.
        flow_control:
            The flow control settings.
        scheduler:
            The scheduler to use to process messages. If not provided, a thread
            pool-based scheduler will be used.
        use_legacy_flow_control:
            If set to ``True``, flow control at the Cloud Pub/Sub server is disabled,
            though client-side flow control is still enabled. If set to ``False``
            (default), both server-side and client-side flow control are enabled.
        await_callbacks_on_shutdown:
            If ``True``, the shutdown thread will wait until all scheduler threads
            terminate and only then proceed with shutting down the remaining running
            helper threads.

            If ``False`` (default), the shutdown thread will shut the scheduler down,
            but it will not wait for the currently executing scheduler threads to
            terminate.

            This setting affects when the on close callbacks get invoked, and
            consequently, when the StreamingPullFuture associated with the stream gets
            resolved.
    """
    def __init__(self, client: subscriber.Client, subscription: str, flow_control: types.FlowControl = ..., scheduler: ThreadScheduler = ..., use_legacy_flow_control: bool = ..., await_callbacks_on_shutdown: bool = ...) -> None:
        ...
    
    @property
    def is_active(self) -> bool:
        """``True`` if this manager is actively streaming.

        Note that ``False`` does not indicate this is complete shut down,
        just that it stopped getting new messages.
        """
        ...
    
    @property
    def flow_control(self) -> types.FlowControl:
        """The active flow control settings."""
        ...
    
    @property
    def dispatcher(self) -> Optional[dispatcher.Dispatcher]:
        """The dispatcher helper."""
        ...
    
    @property
    def leaser(self) -> Optional[leaser.Leaser]:
        """The leaser helper."""
        ...
    
    @property
    def ack_histogram(self) -> histogram.Histogram:
        """The histogram tracking time-to-acknowledge."""
        ...
    
    @property
    def ack_deadline(self) -> float:
        """Return the current ACK deadline based on historical data without updating it.

        Returns:
            The ack deadline.
        """
        ...
    
    @property
    def load(self) -> float:
        """Return the current load.

        The load is represented as a float, where 1.0 represents having
        hit one of the flow control limits, and values between 0.0 and 1.0
        represent how close we are to them. (0.5 means we have exactly half
        of what the flow control setting allows, for example.)

        There are (currently) two flow control settings; this property
        computes how close the manager is to each of them, and returns
        whichever value is higher. (It does not matter that we have lots of
        running room on setting A if setting B is over.)

        Returns:
            The load value.
        """
        ...
    
    def add_close_callback(self, callback: Callable[[StreamingPullManager, Any], Any]) -> None:
        """Schedules a callable when the manager closes.

        Args:
            The method to call.
        """
        ...
    
    def activate_ordering_keys(self, ordering_keys: Iterable[str]) -> None:
        """Send the next message in the queue for each of the passed-in
        ordering keys, if they exist. Clean up state for keys that no longer
        have any queued messages.

        Since the load went down by one message, it's probably safe to send the
        user another message for the same key. Since the released message may be
        bigger than the previous one, this may increase the load above the maximum.
        This decision is by design because it simplifies MessagesOnHold.

        Args:
            ordering_keys:
                A sequence of ordering keys to activate. May be empty.
        """
        ...
    
    def maybe_pause_consumer(self) -> None:
        """Check the current load and pause the consumer if needed."""
        ...
    
    def maybe_resume_consumer(self) -> None:
        """Check the load and held messages and resume the consumer if needed.

        If there are messages held internally, release those messages before
        resuming the consumer. That will avoid leaser overload.
        """
        ...
    
    def send_unary_ack(self, ack_ids, ack_reqs_dict) -> Tuple[List[requests.AckRequest], List[requests.AckRequest]]:
        """Send a request using a separate unary request instead of over the stream.

        If a RetryError occurs, the manager shutdown is triggered, and the
        error is re-raised.
        """
        ...
    
    def send_unary_modack(self, modify_deadline_ack_ids, modify_deadline_seconds, ack_reqs_dict) -> Tuple[List[requests.ModAckRequest], List[requests.ModAckRequest]]:
        """Send a request using a separate unary request instead of over the stream.

        If a RetryError occurs, the manager shutdown is triggered, and the
        error is re-raised.
        """
        ...
    
    def heartbeat(self) -> bool:
        """Sends a heartbeat request over the streaming pull RPC.

        The request is empty by default, but may contain the current ack_deadline
        if the self._exactly_once_enabled flag has changed.

        Returns:
            If a heartbeat request has actually been sent.
        """
        ...
    
    def open(self, callback: Callable[[google.cloud.pubsub_v1.subscriber.message.Message], Any], on_callback_error: Callable[[Exception], Any]) -> None:
        """Begin consuming messages.

        Args:
            callback:
                A callback that will be called for each message received on the
                stream.
            on_callback_error:
                A callable that will be called if an exception is raised in
                the provided `callback`.
        """
        ...
    
    def close(self, reason: Any = ...) -> None:
        """Stop consuming messages and shutdown all helper threads.

        This method is idempotent. Additional calls will have no effect.

        The method does not block, it delegates the shutdown operations to a background
        thread.

        Args:
            reason:
                The reason to close this. If ``None``, this is considered
                an "intentional" shutdown. This is passed to the callbacks
                specified via :meth:`add_close_callback`.
        """
        ...
    


